Major results and ideas from MIT 6.5210.

For DS, our toy problem is MST or shortest paths. Means some operations happen much more often than others; encouraged to get fast `insert`, `merge` etc using laziness techniques.

| Name                  | Claim                                                                                | Idea                                                                                                                                                                                                                                                                                                                                                                                        |
| --------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Fib Heaps**         | *Priority Queue*: $O(1)$ find-min, insert, delete-key, merge; $O(\log n)$ delete-min | Binary heap has these operations using go-down, bubble-up. Balance with a collection of heap-ordered balanced trees. Delete key: mark parent when child cut, cut parent when two children are cut. Can yield recursive cuts but has good amortized performance.                                                                                                                             |
| **Persistence**       | *Data Structure Trick*: be able to read from history                                 | Naively: keep a "fat" timestamped array at each node in the tree. Smarter: copy the path from node to root each time, keep all paths in a single timestamped array. Smartest: copy node only after it is updated once, keep a "fat" array of length at most 2 at each node.                                                                                                                 |
| **Splay Tree**        | *BBST* but with better amortized costs                                               | Claim: *Splaying*, i.e. rot node to root on each access, makes good amortized performance. More commonly accessed nodes end up at the top. Tree can become unbalanced, but only after a lot of work.                                                                                                                                                                                        |
| **Recursive DS**      | *Buckets, vEB Queues, Hashing*: use recursive tables for log lookup                  | To do a PQ for integers: assuming access to super large tables, we can log by the first half, and lookup into a smaller PQ by the second. Assuming not super large access, use recursive lazy buckets with height $\frac{{\log n}}{\log \log n}$ that "trickle down" when new buckets are needed.                                                                                           |
| **Max Flows**         | *Algorithms, Equivalent Problems*: APs, residual graphs, min cut, blocking flows     | In integer case, suffices to find nonstop APs. Repeatedly analyze residual graph. Could create many "reverse" APs, so take shortest AP: $O(m^{2}n)$. Each edge saturates at most $n$ times; distances to $s$ or $t$ cannot decrease. Alternatively, take "blocking flows" that cover all current SAPs, of which we will need at most $n$: $O(mn^{2})$. Well-known that max flow == min cut. |
| **Min Cost Max Flow** | *Min Cost Circ, Re-framings*: using max flow for MCMF                                | After taking max flow, find cycles in the graph with negative cost. After solving this "min cost circulation" we add back to get MCMF. Also can use supply/demand, vertex capacities, etc. all kinds of tricks to adapt various problems to MCMF.                                                                                                                                           |
| **LPs**               |                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                             |
